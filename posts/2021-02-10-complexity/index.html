<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>알고리즘 복잡도 | WY Seo Blog</title><meta name=keywords content="algorithm,python"><meta name=description content="adsfasdfasdf  애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 알고리즘 복잡도 1.1. 개념 1.1.1. 알고리즘 복잡도 계산이 필요한 이유  하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음. 여러가지 방법 중 어느 방법이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산함. 어느 것이 더 좋은 알고리즘인지 판단하는 기준이 됨.  1.1.2. 알고리즘 복잡도를 계산하는 방식  공간 복잡도 (space complexity)  알고리즘이 사용하는 메모리 사이즈   시간 복잡도 (time complexity)  알고리즘 실행 속도 특히, 시간 복잡도에 대한 이해는 필수    1."><meta name=author content="Me"><link rel=canonical href=https://lucaseo.github.io/posts/2021-02-10-complexity/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.b7f6713cadc5227981722b34719045289db05abaee650dc59d1de005a81e742c.css integrity="sha256-t/ZxPK3FInmBcis0cZBFKJ2wWrruZQ3FnR3gBagedCw=" rel="preload stylesheet" as=style><link rel=icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="알고리즘 복잡도"><meta property="og:description" content="adsfasdfasdf  애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 알고리즘 복잡도 1.1. 개념 1.1.1. 알고리즘 복잡도 계산이 필요한 이유  하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음. 여러가지 방법 중 어느 방법이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산함. 어느 것이 더 좋은 알고리즘인지 판단하는 기준이 됨.  1.1.2. 알고리즘 복잡도를 계산하는 방식  공간 복잡도 (space complexity)  알고리즘이 사용하는 메모리 사이즈   시간 복잡도 (time complexity)  알고리즘 실행 속도 특히, 시간 복잡도에 대한 이해는 필수    1."><meta property="og:type" content="article"><meta property="og:url" content="https://lucaseo.github.io/posts/2021-02-10-complexity/"><meta property="og:image" content="https://lucaseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2021-02-10T14:24:01+09:00"><meta property="article:modified_time" content="2021-02-10T14:24:01+09:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lucaseo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="알고리즘 복잡도"><meta name=twitter:description content="adsfasdfasdf  애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)
 1. 알고리즘 복잡도 1.1. 개념 1.1.1. 알고리즘 복잡도 계산이 필요한 이유  하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음. 여러가지 방법 중 어느 방법이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산함. 어느 것이 더 좋은 알고리즘인지 판단하는 기준이 됨.  1.1.2. 알고리즘 복잡도를 계산하는 방식  공간 복잡도 (space complexity)  알고리즘이 사용하는 메모리 사이즈   시간 복잡도 (time complexity)  알고리즘 실행 속도 특히, 시간 복잡도에 대한 이해는 필수    1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"알고리즘 복잡도","name":"알고리즘 복잡도","description":"adsfasdfasdf  애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)\n 1. 알고리즘 복잡도 1.1. 개념 1.1.1. 알고리즘 복잡도 계산이 필요한 이유  하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음. 여러가지 방 …","keywords":["algorithm","python"],"articleBody":"adsfasdfasdf  애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)\n 1. 알고리즘 복잡도 1.1. 개념 1.1.1. 알고리즘 복잡도 계산이 필요한 이유  하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음. 여러가지 방법 중 어느 방법이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산함. 어느 것이 더 좋은 알고리즘인지 판단하는 기준이 됨.  1.1.2. 알고리즘 복잡도를 계산하는 방식  공간 복잡도 (space complexity)  알고리즘이 사용하는 메모리 사이즈   시간 복잡도 (time complexity)  알고리즘 실행 속도 특히, 시간 복잡도에 대한 이해는 필수    1.1.3. 알고리즘 시간 복잡도의 주요 요소  반복문이 얼마나 시행되었는지에 따라 시간 복잡도의 성능이 결정된다고 할 수 있음. 입력의 크기가 커지면 커질 수록 반복문이 알고리즘 수행 시간을 지배함.  1.2. 복잡도 표기법 유형 1.2.1. Big-O 표기법 $O(N)$  알고리즘 최악의 실행시간을 표기함 아무리 최악의 상황이라도 이 정도의 성능은 보장한다는 의미 가장 많이(일반적으로) 사용함  1.2.2. 오메가 표기법 $\\Omega(N)$  최상의 알고리즘 실행 시간을 표기  1.2.3. 세타 표기법 $\\Theta(N)$  알고리즘 평균 실행 시간을 표기  1.3. Big-O 표기법 1.3.1. $O(n)$  입력 $n$에 따라 결정되는 시간 복잡도 함수.  $O(1)$ $O(\\log n)$ $O(n)$ $O(n \\log n)$ $O(n^2)$ $O(2^n)$ $O(n!)$   입력에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음.  $O(1)    1.3.2. 계산법  $O(1)$  단순하게 입력 $n$에 따라 멸번 실행이 되는지 계산함. 실행은 무조건 2회(또는 상수회) 실행한다.  if n  10: print(n)  $O(n)$  $n$에 따라 $n$번 또는 $k \\cdot n + b$ 실행한다.  for idx in range(n): print(idx)  $O(n^2)$  $n$에 따라 $n^2$번 또는 $k \\cdot n^2 + b$ 등을 실행한다.  for num in range(n): for index in range(n): print(index)   1.3.3. 표기 방법  시간복잡도는 결국 입력값 $n$에 따라 성능이 결정됨. 결국 알고리즘 성능에 가장 영향을 끼치는 값을 기준으로 표기함. 따라서 상수 $k, b$는 표기할 때 생략함 $k \\cdot n^2 + b$의 경우 Big-O 표기법으로는 $O(n^2)$으로 표기함.  2. Reference  Fastcampus 알고리즘 / 기술면접 강의  ","wordCount":"299","inLanguage":"en","datePublished":"2021-02-10T14:24:01+09:00","dateModified":"2021-02-10T14:24:01+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lucaseo.github.io/posts/2021-02-10-complexity/"},"publisher":{"@type":"Organization","name":"WY Seo Blog","logo":{"@type":"ImageObject","url":"https://lucaseo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://lucaseo.github.io/ accesskey=h title="WY Seo Blog (Alt + H)">WY Seo Blog</a>
<span class=logo-switches><a id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://lucaseo.github.io/archives/ title=posts><span>posts</span></a></li><li><a href=https://lucaseo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://lucaseo.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://lucaseo.github.io/about/ title=about><span>about</span></a></li><li><a href=https://lucaseo.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>알고리즘 복잡도</h1><div class=post-meta>February 10, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=adsfasdfasdf>adsfasdfasdf<a hidden class=anchor aria-hidden=true href=#adsfasdfasdf>#</a></h1><blockquote><p><em>애매모호하게만 알고 있는 자료구조를 다시 공부하고 정리하는 포스트입니다. 잘 못 이해하고 있는 부분이 있다면 주저없이 지적 부탁 드립니다 :)</em></p></blockquote><h1 id=1-알고리즘-복잡도>1. 알고리즘 복잡도<a hidden class=anchor aria-hidden=true href=#1-알고리즘-복잡도>#</a></h1><h2 id=11-개념>1.1. 개념<a hidden class=anchor aria-hidden=true href=#11-개념>#</a></h2><h3 id=111-알고리즘-복잡도-계산이-필요한-이유>1.1.1. 알고리즘 복잡도 계산이 필요한 이유<a hidden class=anchor aria-hidden=true href=#111-알고리즘-복잡도-계산이-필요한-이유>#</a></h3><ul><li>하나의 문제를 푸는 방법(알고리즘)은 다양할 수 있음.</li><li>여러가지 방법 중 어느 방법이 더 좋은지를 분석하기 위해 복잡도를 정의하고 계산함.</li><li>어느 것이 더 좋은 알고리즘인지 판단하는 기준이 됨.</li></ul><h3 id=112-알고리즘-복잡도를-계산하는-방식>1.1.2. 알고리즘 복잡도를 계산하는 방식<a hidden class=anchor aria-hidden=true href=#112-알고리즘-복잡도를-계산하는-방식>#</a></h3><ol><li>공간 복잡도 (space complexity)<ul><li>알고리즘이 사용하는 메모리 사이즈</li></ul></li><li>시간 복잡도 (time complexity)<ul><li>알고리즘 실행 속도</li><li>특히, 시간 복잡도에 대한 이해는 필수</li></ul></li></ol><h3 id=113-알고리즘-시간-복잡도의-주요-요소>1.1.3. 알고리즘 시간 복잡도의 주요 요소<a hidden class=anchor aria-hidden=true href=#113-알고리즘-시간-복잡도의-주요-요소>#</a></h3><ul><li>반복문이 얼마나 시행되었는지에 따라 시간 복잡도의 성능이 결정된다고 할 수 있음.</li><li>입력의 크기가 커지면 커질 수록 반복문이 알고리즘 수행 시간을 지배함.</li></ul><h2 id=12-복잡도-표기법-유형>1.2. 복잡도 표기법 유형<a hidden class=anchor aria-hidden=true href=#12-복잡도-표기법-유형>#</a></h2><h3 id=121-big-o-표기법-on>1.2.1. Big-O 표기법 $O(N)$<a hidden class=anchor aria-hidden=true href=#121-big-o-표기법-on>#</a></h3><ul><li>알고리즘 최악의 실행시간을 표기함</li><li>아무리 최악의 상황이라도 이 정도의 성능은 보장한다는 의미</li><li>가장 많이(일반적으로) 사용함</li></ul><h3 id=122-오메가-표기법-omegan>1.2.2. 오메가 표기법 $\Omega(N)$<a hidden class=anchor aria-hidden=true href=#122-오메가-표기법-omegan>#</a></h3><ul><li>최상의 알고리즘 실행 시간을 표기</li></ul><h3 id=123-세타-표기법-thetan>1.2.3. 세타 표기법 $\Theta(N)$<a hidden class=anchor aria-hidden=true href=#123-세타-표기법-thetan>#</a></h3><ul><li>알고리즘 평균 실행 시간을 표기</li></ul><h2 id=13-big-o-표기법>1.3. Big-O 표기법<a hidden class=anchor aria-hidden=true href=#13-big-o-표기법>#</a></h2><h3 id=131-on>1.3.1. $O(n)$<a hidden class=anchor aria-hidden=true href=#131-on>#</a></h3><ul><li>입력 $n$에 따라 결정되는 시간 복잡도 함수.<ul><li>$O(1)$</li><li>$O(\log n)$</li><li>$O(n)$</li><li>$O(n \log n)$</li><li>$O(n^2)$</li><li>$O(2^n)$</li><li>$O(n!)$</li></ul></li><li>입력에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음.<ul><li>$O(1) &lt; O(\log n) &lt; O(n) &lt; O(n \log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$</li></ul></li></ul><h3 id=132-계산법>1.3.2. 계산법<a hidden class=anchor aria-hidden=true href=#132-계산법>#</a></h3><ul><li>$O(1)$<ul><li>단순하게 입력 $n$에 따라 멸번 실행이 되는지 계산함.</li><li>실행은 무조건 2회(또는 상수회) 실행한다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span>:
        <span style=color:#66d9ef>print</span>(n)
</code></pre></div></li><li>$O(n)$<ul><li>$n$에 따라 $n$번 또는 $k \cdot n + b$ 실행한다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#66d9ef>for</span> idx <span style=color:#f92672>in</span> range(n):
        <span style=color:#66d9ef>print</span>(idx)
</code></pre></div></li><li>$O(n^2)$<ul><li>$n$에 따라 $n^2$번 또는 $k \cdot n^2 + b$ 등을 실행한다.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#66d9ef>for</span> num <span style=color:#f92672>in</span> range(n):
        <span style=color:#66d9ef>for</span> index <span style=color:#f92672>in</span> range(n):
                <span style=color:#66d9ef>print</span>(index)
</code></pre></div></li></ul><h3 id=133-표기-방법>1.3.3. 표기 방법<a hidden class=anchor aria-hidden=true href=#133-표기-방법>#</a></h3><ul><li>시간복잡도는 결국 입력값 $n$에 따라 성능이 결정됨.</li><li>결국 알고리즘 성능에 가장 영향을 끼치는 값을 기준으로 표기함.</li><li>따라서 상수 $k, b$는 표기할 때 생략함</li><li>$k \cdot n^2 + b$의 경우 Big-O 표기법으로는 $O(n^2)$으로 표기함.</li></ul><p><img src=https://flamingotiger.github.io/image/DevTIL/Algorithm/algorithm-bigo_0.jpg alt></p><h1 id=2-reference>2. Reference<a hidden class=anchor aria-hidden=true href=#2-reference>#</a></h1><ul><li>Fastcampus 알고리즘 / 기술면접 강의</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lucaseo.github.io/tags/algorithm/>algorithm</a></li><li><a href=https://lucaseo.github.io/tags/python/>python</a></li></ul></footer></article></main><footer class=footer><span>© Wonyoung Seo 2021</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>